#CHAPTER 1
####1. 按照1.9节末尾的步骤找出你自己的网络拓扑信息。
netstat -ni
netstat -nr
ifconfig wlp3s0
ping -b 10.30.31.255
####2. 编译并测试图1-5所示的TCP时间获取客户程序。运行这个程序若干次，每次以不同的IP地址作为命令行参数。
测试成功的三组：
0.0.0.0
127.0.0.1
10.30.11.6（本地IP地址）
####3.把图1-5中的socket的第一个参数改为9999，并运行这个程序。结果如何？找出对应于输出出错的error值。你如何可以找到关于这个错误的更多信息。
程序输出**socket error: Address family not support by protocol**
顾名思义，错误的地址族
####4.修改图1-5中的while循环，加入一个计算器，累计read返回大于零的次数。在终止程序前输出这个计数器值。编译并运行你的新客户程序。
因为每次返回的时间总是小于MAXLEN，故执行了一次read函数，所以计数值总为1。 
####5. 修改图1-9的程序，首先，把赋予sin_port的端口号从13修改为9999。然后，把write的单一调用改为循环调用，每次写出结果字符串的一个字符。编译修改后的服务器程序并在后台启动执行。接着修改前一道习题中的客户程序（它在终止前输出计算器值），把赋予sin_port的端口号从13改为9999。启动这个客户程序，指定运行修改后的服务器程序的主机和IP地址作为命令行参数。客户程序计数器的输出值是多少？如果可能，在不同的主机上运行这个客户和服务器程序。
客户和服务器在同一主机上测试计数值总为1，只进行一次读，并且不在网络上进行数据传输。
如果在网络上进行数据传输该值可能就会改变。
本例子的目的在于强调不同的TCP对数据做不同的处理，我们的应用程序必须做好作为字节刘读入这些数据的准备，直到遇上数据流末尾。