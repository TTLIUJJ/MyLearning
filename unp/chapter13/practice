#CHAPTER 13
####1. 图13-5中如果我们把daemon_init调用挪到检查命令行参数之前，使得err_quit调用位于daemon_init调用之后，那会发生什么？
daemon_init中关闭所有描述符的close调用也将关闭由tcp_listen建立的监听套接字。
既然守护进程编写的程序可能从某个系统启动命令脚本执行，我们不能假设任何出错信息都能写到某个终端 ，这样可能使得cerr_quit的出错信息不能输出。
所有的出错信息应该使用syslog登记，诸如命令行参数无效之类的启动出错消息。
####2. 对于由inetd内部处理的5个服务（图2-8），考虑每个服务各有一个TCP版本和一个UDP版本，这样总共10个服务器的实现中，哪些用到了fork调用，哪些不需要fork调用。
TCP版本的echo、discard和chargen服务器由inetd派生出来之后作为子进程运行，因为它们需要运行到客户终止连接为止。而time和daytime并不需要inetd派生子进程，因为它们的服务极易实现，由inetd直接处理。
5个UDP版本的服务都不需要inetd派生子进程，因为每个服务器对于引发它的任一客户数据报所作的响应最多产生一个数据报（UDP是面向无连接的数据传输，根本不必等到客户终止连接），所以有inetd直接处理。
####3. 如果我们创建一个UDP套接字，把端口7（如图2-18中标准echo服务器所用端口）绑到其上，然后把一个UDP数据报发送到某个标准chargen服务器，将会发生什么？
这是一个拒绝服务型攻击。
来自端口7的第一个数据报导致chargen服务器发送回一个数据报到端口7，接着又作为下一个数据报被回射给chargen服务器，如此无限循环下去。